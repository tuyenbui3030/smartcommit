#!/usr/bin/env bash

# ============================================================
# git-ai: AI-powered commit message generator
# ============================================================
# 
# Usage: git ai [options]
# 
# Options:
#   -h, --help      Show this help message
#   -v, --version   Show version
#   -y, --yes       Skip confirmation prompt
#   -q, --quick     Quick mode: stage all, commit, and push/publish
#   --setup         Configure API settings
#   --upgrade       Upgrade to latest version
#
# Environment variables:
#   GIT_AI_URL     - API endpoint (required)
#   GIT_AI_KEY     - API key (required)
#   GIT_AI_MODEL   - Model name (default: gemini-2.5-flash-preview)
#   GIT_AI_DETAILED - Generate detailed messages (true/false)
#
# Example:
#   export GIT_AI_URL="https://api.openai.com/v1/chat/completions"
#   export GIT_AI_KEY="sk-xxx"
#   export GIT_AI_MODEL="gemini-2.5-flash-preview"
#
# Branch naming convention:
#   feat/123-description  ‚Üí feat: #123 <message>
#   fix/JIRA-88-bug       ‚Üí fix: #JIRA-88 <message>
# ============================================================

VERSION="1.1.0"

# -------- parse arguments --------
SKIP_CONFIRM=false
QUICK_MODE=false
EXTRA_ARGS=()

for arg in "$@"; do
  case $arg in
    -h|--help)
      sed -n '3,26p' "$0" | sed 's/^# //' | sed 's/^#//'
      exit 0
      ;;
    -v|--version)
      echo "git-ai v$VERSION"
      exit 0
      ;;
    --setup)
      # Load existing config if available
      CONFIG_FILE="$HOME/.config/git-ai/config"
      if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
      fi
      
      # Extract host from existing URL (remove /v1/chat/completions)
      OLD_HOST="${GIT_AI_URL%/v1/chat/completions}"
      OLD_KEY="${GIT_AI_KEY:-}"
      OLD_MODEL="${GIT_AI_MODEL:-gemini-2.5-flash-preview}"
      OLD_DETAILED="${GIT_AI_DETAILED:-false}"
      
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo "ü§ñ git-ai setup"
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo ""
      
      # API Host
      if [ -n "$OLD_HOST" ]; then
        read -r -p "API Host [$OLD_HOST]: " SETUP_HOST
        SETUP_HOST=${SETUP_HOST:-$OLD_HOST}
      else
        read -r -p "API Host (e.g., https://api.openai.com): " SETUP_HOST
      fi
      SETUP_HOST=${SETUP_HOST%/}
      
      # API Key
      if [ -n "$OLD_KEY" ]; then
        read -r -p "API Key [${OLD_KEY:0:10}...]: " SETUP_KEY
        SETUP_KEY=${SETUP_KEY:-$OLD_KEY}
      else
        read -r -p "API Key: " SETUP_KEY
      fi
      
      # Model
      read -r -p "Model [$OLD_MODEL]: " SETUP_MODEL
      SETUP_MODEL=${SETUP_MODEL:-$OLD_MODEL}
      
      echo ""
      echo "Message style:"
      echo "  1) Short  - feat: add cancel button"
      echo "  2) Detail - feat(scope): summary + bullet list"
      if [ "$OLD_DETAILED" = "true" ]; then
        OLD_STYLE="2"
      else
        OLD_STYLE="1"
      fi
      read -r -p "Choose [$OLD_STYLE]: " SETUP_STYLE
      SETUP_STYLE=${SETUP_STYLE:-$OLD_STYLE}
      if [[ "$SETUP_STYLE" == "2" ]]; then
        SETUP_DETAILED="true"
      else
        SETUP_DETAILED="false"
      fi
      
      if [ -z "$SETUP_HOST" ] || [ -z "$SETUP_KEY" ]; then
        echo "‚ùå Host and Key are required"
        exit 1
      fi
      
      mkdir -p "$HOME/.config/git-ai"
      cat > "$HOME/.config/git-ai/config" << EOF
GIT_AI_URL="$SETUP_HOST/v1/chat/completions"
GIT_AI_KEY="$SETUP_KEY"
GIT_AI_MODEL="$SETUP_MODEL"
GIT_AI_DETAILED="$SETUP_DETAILED"
EOF
      chmod 600 "$HOME/.config/git-ai/config"
      
      echo ""
      echo "‚úÖ Config saved to ~/.config/git-ai/config"
      echo ""
      echo "üîß Configuration:"
      echo "   URL     = $SETUP_HOST/v1/chat/completions"
      echo "   KEY     = ${SETUP_KEY:0:10}..."
      echo "   MODEL   = $SETUP_MODEL"
      echo "   STYLE   = $([ "$SETUP_DETAILED" = "true" ] && echo "detailed" || echo "short")"
      exit 0
      ;;
    --upgrade)
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo "üîÑ git-ai upgrade"
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo ""
      echo "Current version: v$VERSION"
      echo ""
      
      REPO_URL="https://raw.githubusercontent.com/tuyenbui3030/smartcommit/main"
      
      # Check latest version
      echo "üîç Checking for updates..."
      LATEST_SCRIPT=$(curl -fsSL "$REPO_URL/git-ai" 2>/dev/null)
      if [ -z "$LATEST_SCRIPT" ]; then
        echo "‚ùå Failed to fetch latest version"
        exit 1
      fi
      
      LATEST_VERSION=$(echo "$LATEST_SCRIPT" | grep -m1 'VERSION=' | cut -d'"' -f2)
      echo "Latest version:  v$LATEST_VERSION"
      echo ""
      
      if [ "$VERSION" = "$LATEST_VERSION" ]; then
        echo "‚úÖ You're already on the latest version!"
        exit 0
      fi
      
      # Determine install location
      INSTALL_PATH=$(which git-ai 2>/dev/null || echo "/usr/local/bin/git-ai")
      
      echo "üì¶ Upgrading to v$LATEST_VERSION..."
      echo "   Install path: $INSTALL_PATH"
      echo ""
      
      # Check if we need sudo
      if [ -w "$INSTALL_PATH" ] || [ -w "$(dirname "$INSTALL_PATH")" ]; then
        echo "$LATEST_SCRIPT" > "$INSTALL_PATH"
        chmod 755 "$INSTALL_PATH"
      else
        echo "‚ö†Ô∏è  Root permission required"
        echo "$LATEST_SCRIPT" | sudo tee "$INSTALL_PATH" > /dev/null
        sudo chmod 755 "$INSTALL_PATH"
      fi
      
      echo ""
      echo "‚úÖ Successfully upgraded to v$LATEST_VERSION!"
      exit 0
      ;;
    -y|--yes)
      SKIP_CONFIRM=true
      ;;
    -q|--quick)
      QUICK_MODE=true
      SKIP_CONFIRM=true
      ;;
    *)
      EXTRA_ARGS+=("$arg")
      ;;
  esac
done

# -------- check requirements --------
if ! command -v jq &> /dev/null; then
  echo "‚ùå jq is required. Install: brew install jq"
  exit 1
fi

if ! command -v curl &> /dev/null; then
  echo "‚ùå curl is required."
  exit 1
fi

# -------- load config file --------
CONFIG_FILE="$HOME/.config/git-ai/config"

if [ -f "$CONFIG_FILE" ]; then
  source "$CONFIG_FILE"
fi

# -------- check config --------
if [ -z "${GIT_AI_URL:-}" ]; then
  echo "‚ùå GIT_AI_URL is not set"
  echo ""
  echo "Run: git ai --setup"
  exit 1
fi

if [ -z "${GIT_AI_KEY:-}" ]; then
  echo "‚ùå GIT_AI_KEY is not set"
  echo ""
  echo "Run: git ai --setup"
  exit 1
fi

GIT_AI_MODEL="${GIT_AI_MODEL:-gemini-2.5-flash-preview}"
GIT_AI_DETAILED="${GIT_AI_DETAILED:-false}"

# -------- check git state --------
if ! git rev-parse --git-dir &> /dev/null; then
  echo "‚ùå Not a git repository"
  exit 1
fi

BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null)

if [ -z "$BRANCH" ]; then
  echo "‚ùå Not on a branch (detached HEAD)"
  exit 1
fi

# -------- quick mode: stage all changes --------
if [ "$QUICK_MODE" = true ]; then
  echo "üöÄ Quick mode: staging all changes..."
  git add .
fi

# -------- type from branch --------
# Try to detect type from branch name, otherwise let AI decide
if [[ "$BRANCH" =~ (^|/)(fix|bugfix|hotfix)($|/|[^a-z]) ]]; then
  TYPE="fix"
elif [[ "$BRANCH" =~ (^|/)(feat|feature)($|/|[^a-z]) ]]; then
  TYPE="feat"
elif [[ "$BRANCH" =~ (^|/)(chore)($|/|[^a-z]) ]]; then
  TYPE="chore"
elif [[ "$BRANCH" =~ (^|/)(docs)($|/|[^a-z]) ]]; then
  TYPE="docs"
elif [[ "$BRANCH" =~ (^|/)(refactor)($|/|[^a-z]) ]]; then
  TYPE="refactor"
elif [[ "$BRANCH" =~ (^|/)(test|tests)($|/|[^a-z]) ]]; then
  TYPE="test"
elif [[ "$BRANCH" =~ (^|/)(style)($|/|[^a-z]) ]]; then
  TYPE="style"
elif [[ "$BRANCH" =~ (^|/)(perf)($|/|[^a-z]) ]]; then
  TYPE="perf"
elif [[ "$BRANCH" =~ (^|/)(ci)($|/|[^a-z]) ]]; then
  TYPE="ci"
else
  TYPE=""
fi

# -------- ticket from branch --------
# Match: ABC-123, #2, #123, or 3+ digit numbers
if [[ "$BRANCH" =~ ([A-Z]+-[0-9]+|#[0-9]+|[0-9]{3,}) ]]; then
  TICKET="${BASH_REMATCH[1]}"
  TICKET="${TICKET#\#}"  # Remove leading # if present
else
  TICKET=""
fi

# -------- get diff --------
DIFF=$(git diff --cached --no-color 2>/dev/null)
if [ -z "$DIFF" ]; then
  echo "‚ùå No staged changes"
  echo ""
  echo "Run: git add <files>"
  exit 1
fi

echo "ü§ñ Generating commit message..."

# Truncate diff if too long (max 4000 chars)
DIFF_TRUNCATED=$(echo "$DIFF" | head -c 4000)

# Build prompt based on detailed mode and whether we detected a type
if [ "$GIT_AI_DETAILED" = "true" ]; then
  # Detailed mode: generate structured multi-line message
  if [ -n "$TYPE" ]; then
    PROMPT="Generate a detailed git commit message with scope and bullet points.
Format:
(scope): short summary (max 50 chars)

One paragraph explaining the change (2-3 sentences).

- Bullet point for each significant change
- Use present tense, start with verb
- Be specific about what was added/changed/removed

Do not include the type prefix in your response, only the scope and message.
Do not wrap in quotes.
Output ONLY the commit message, no explanations.

Diff:
$DIFF_TRUNCATED"
  else
    PROMPT="Generate a detailed git commit message with type, scope and bullet points.
Format:
type(scope): short summary (max 50 chars)

One paragraph explaining the change (2-3 sentences).

- Bullet point for each significant change
- Use present tense, start with verb
- Be specific about what was added/changed/removed

Types: feat, fix, chore, docs, refactor, test, style, perf, ci
Do not wrap in quotes.
Output ONLY the commit message, no explanations.

Diff:
$DIFF_TRUNCATED"
  fi
  MAX_TOKENS=2000
else
  # Short mode (original behavior)
  if [ -n "$TYPE" ]; then
    PROMPT="Generate a short git commit message body (max 50 chars). 
Do not include type prefix or ticket number.
Use present tense, lowercase.
Only output the message text, nothing else.
Do not wrap in quotes.

Diff:
$DIFF_TRUNCATED"
  else
    PROMPT="Generate a short git commit message with type prefix (max 60 chars).
Use conventional commit format: type: message
Types: feat, fix, chore, docs, refactor, test, style, perf, ci
Use present tense, lowercase.
Only output the commit message, nothing else.
Do not wrap in quotes.

Diff:
$DIFF_TRUNCATED"
  fi
  MAX_TOKENS=100
fi

PROMPT_ESCAPED=$(echo "$PROMPT" | jq -Rs .)

# -------- call AI API --------
CURL_OUTPUT=$(mktemp)
trap "rm -f $CURL_OUTPUT" EXIT

HTTP_STATUS=$(curl -s -w "%{http_code}" --max-time 30 "$GIT_AI_URL" \
  -H "Authorization: Bearer $GIT_AI_KEY" \
  -H "Content-Type: application/json" \
  -d "{
    \"model\": \"$GIT_AI_MODEL\",
    \"messages\": [{\"role\": \"user\", \"content\": $PROMPT_ESCAPED}],
    \"max_tokens\": $MAX_TOKENS
  }" -o "$CURL_OUTPUT" 2>&1)

CURL_EXIT=$?
RESPONSE_BODY=$(cat "$CURL_OUTPUT" 2>/dev/null || echo "")

# -------- handle curl errors --------
if [ $CURL_EXIT -ne 0 ]; then
  echo ""
  echo "‚ùå Network Error (curl exit code: $CURL_EXIT)"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  case $CURL_EXIT in
    6)  echo "Could not resolve host" ;;
    7)  echo "Failed to connect to host" ;;
    28) echo "Connection timed out (30s)" ;;
    *)  echo "curl error: $CURL_EXIT" ;;
  esac
  echo "URL: $GIT_AI_URL"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  exit 1
fi

# -------- handle HTTP errors --------
if [ "$HTTP_STATUS" != "200" ]; then
  echo ""
  echo "‚ùå API Error (HTTP $HTTP_STATUS)"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "URL: $GIT_AI_URL"
  echo "Model: $GIT_AI_MODEL"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "Response:"
  echo "$RESPONSE_BODY" | jq . 2>/dev/null || echo "$RESPONSE_BODY"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  exit 1
fi

# -------- parse response --------
MESSAGE=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // empty' 2>/dev/null)

if [ -z "$MESSAGE" ]; then
  echo ""
  echo "‚ùå Failed to parse AI response"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "Response:"
  echo "$RESPONSE_BODY" | jq . 2>/dev/null || echo "$RESPONSE_BODY"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  exit 1
fi

# Build commit message based on mode
if [ "$GIT_AI_DETAILED" = "true" ]; then
  # Detailed mode: preserve multi-line structure
  MESSAGE=$(echo "$MESSAGE" | sed "s/^[\"']*//;s/[\"']*$//")
  
  # Regex patterns for bash
  SCOPE_REGEX='^\([^)]+\):'
  TYPE_REGEX='^[a-z]+(\([^)]+\))?:'
  
  # For detailed mode with detected type, prepend type to first line
  if [ -n "$TYPE" ]; then
    FIRST_LINE=$(echo "$MESSAGE" | head -n 1)
    REST=$(echo "$MESSAGE" | tail -n +2)
    
    # Check if first line starts with scope like "(scope):"
    if [[ "$FIRST_LINE" =~ $SCOPE_REGEX ]]; then
      FIRST_LINE="$TYPE$FIRST_LINE"
    elif [[ ! "$FIRST_LINE" =~ $TYPE_REGEX ]]; then
      FIRST_LINE="$TYPE: $FIRST_LINE"
    fi
    
    # Add ticket if present
    if [ -n "$TICKET" ]; then
      FIRST_LINE=$(echo "$FIRST_LINE" | sed "s/: /: #$TICKET /")
    fi
    
    if [ -n "$REST" ]; then
      COMMIT_MSG="$FIRST_LINE
$REST"
    else
      COMMIT_MSG="$FIRST_LINE"
    fi
  else
    # No type detected, use AI's full message
    if [ -n "$TICKET" ]; then
      FIRST_LINE=$(echo "$MESSAGE" | head -n 1)
      REST=$(echo "$MESSAGE" | tail -n +2)
      FIRST_LINE=$(echo "$FIRST_LINE" | sed "s/: /: #$TICKET /")
      if [ -n "$REST" ]; then
        COMMIT_MSG="$FIRST_LINE
$REST"
      else
        COMMIT_MSG="$FIRST_LINE"
      fi
    else
      COMMIT_MSG="$MESSAGE"
    fi
  fi
else
  # Short mode: original behavior
  MESSAGE=$(echo "$MESSAGE" | tr -d '\n' | sed "s/^[\"']*//;s/[\"']*$//" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '[:upper:]' '[:lower:]' | head -c 60)

  if [ -n "$TYPE" ]; then
    if [ -n "$TICKET" ]; then
      COMMIT_MSG="$TYPE: #$TICKET $MESSAGE"
    else
      COMMIT_MSG="$TYPE: $MESSAGE"
    fi
  else
    if [ -n "$TICKET" ]; then
      if [[ "$MESSAGE" =~ ^([a-z]+):(.*)$ ]]; then
        COMMIT_MSG="${BASH_REMATCH[1]}: #$TICKET${BASH_REMATCH[2]}"
      else
        COMMIT_MSG="#$TICKET $MESSAGE"
      fi
    else
      COMMIT_MSG="$MESSAGE"
    fi
  fi
fi

echo ""
echo "üìù Commit message:"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "$COMMIT_MSG"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""

# -------- confirm --------
if [ "$SKIP_CONFIRM" = true ]; then
  git commit -m "$COMMIT_MSG" "${EXTRA_ARGS[@]}"
  
  # -------- quick mode: push/publish --------
  if [ "$QUICK_MODE" = true ]; then
    echo ""
    if [[ "$BRANCH" == feature/* ]]; then
      FEATURE_NAME=${BRANCH#feature/}
      echo "üöÄ Publishing feature branch: $FEATURE_NAME"
      git flow feature publish "$FEATURE_NAME" 2>/dev/null || git push -u origin "$BRANCH"
    else
      echo "üöÄ Pushing to origin..."
      git push
    fi
  fi
  
  exit 0
fi

read -r -p "Commit? [Y/n/e(dit)] " CONFIRM || { echo ""; echo "‚ùå Cancelled"; exit 1; }
CONFIRM=${CONFIRM:-Y}

if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
  git commit -m "$COMMIT_MSG" "${EXTRA_ARGS[@]}"
elif [[ "$CONFIRM" =~ ^[Ee]$ ]]; then
  git commit -e -m "$COMMIT_MSG" "${EXTRA_ARGS[@]}"
else
  echo "‚ùå Cancelled"
  exit 1
fi
